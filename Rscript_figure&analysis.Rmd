---
title: "Temporal Control of Branch Development Maintains Vegetative Meristems in Perennial Grasses - Rscript"
output:
  html_document:
    theme: cerulean
    code_folding: hide
    code_download: true
editor_options: 
  markdown: 
    wrap: sentence
---

```{r}
knitr::opts_chunk$set(echo=TRUE, 
                      warning=FALSE, 
                      message=FALSE)
```

```{r}
#importing packages
library(readxl)
library(dplyr)
library(tibble)
library(ggplot2)
library(glmmTMB)
library(broom.mixed)
library(emmeans)
library(effects)
library(modelsummary)

```
# (1) annual species will branch faster than perennials

## Importing data and preprosessing

To prepare the dataset for analysis, the variables Habit, Subtribe, and Individual were converted to factors. A new variable, interaction_var, was then created to represent the unique combinations of Habit and Subtribe. Within each of these groups, individuals were reassigned new IDs (Individual_new) using dense_rank(), providing consecutively numbered factor levels (e.g., "ID1", "ID2", etc.). This step ensures consistent labeling of individuals within each group. Finally, Subtribe was refactored to update its levels after grouping operations.

```{r}

# ============================================================
# Data Import and Harmonization
# ============================================================

# Import the dataset and harmonize taxon labels across years and paired taxa
dta <- read_excel("Data/Data 1.xlsx", sheet = "Fig. 1 and 2") %>%
  mutate(
    Subtribe = case_when(
      Subtribe == "Brachypodium" & Year == 2021 ~ "Brachypodium (2021)",
      Subtribe == "Brachypodium" & Year == 2022 ~ "Brachypodium (2022)",
      Subtribe == "Dactylidinae"                ~ "Lamarckia & Dactylis",
      Subtribe == "Arctagrostis"                ~ "Beckmannia & Arctagrostis",
      TRUE ~ Subtribe
    ),
    Habit      = factor(Habit),
    Subtribe   = factor(Subtribe),
    Individual = factor(Individual)
  ) %>%
  group_by(Habit, Subtribe) %>%
  mutate(Individual_new = factor(paste0("ID", dense_rank(Individual)))) %>%
  ungroup()

# ============================================================
# Time-Series Definition and Day-to-Day Differences
# ============================================================

# Define time series based on the first observation day and compute successive day differences
dta_diff <- dta %>%
  mutate(Time_series = cumsum(`Days shoot` == 1)) %>%
  group_by(Time_series) %>%
  arrange(Time_series, `Days shoot`) %>%
  mutate(
    Ordered_Days_shoot = `Days shoot`,
    Difference = c(NA, diff(`Days shoot`))
  ) %>%
  filter(!is.na(Difference)) %>%
  ungroup() %>%
  mutate(
    Subtribe = factor(Subtribe, levels = c(
      "Brachypodium (2021)",
      "Brachypodium (2022)",
      "Bromus",
      "Hordeum",
      "Briza",
      "Lamarckia & Dactylis",
      "Festuca",
      "Phalaris",
      "Beckmannia & Arctagrostis"
    ))
  )


# ============================================================
# Sample Size Summaries
# ============================================================

```

To generate the dataset used for Figure 1, observations were first aggregated within each time series by counting the number of records per day and computing a cumulative sum over time. A single row of associated metadata (year, taxon, and life-history category) was then retained for each time series and joined to the cumulative counts, producing the final plotting dataset (dta_cum).

```{r}

# ============================================================
# Cumulative Counts per Time Series
# ============================================================

# Count observations per day within each time series and compute cumulative totals
new_dta_diff <- dta_diff %>%
  count(Time_series, Ordered_Days_shoot, name = "number_days_shoot") %>%
  arrange(Time_series, Ordered_Days_shoot) %>%
  group_by(Time_series) %>%
  mutate(cumulative_sum = cumsum(number_days_shoot)) %>%
  ungroup()

# ============================================================
# Metadata per Time Series
# ============================================================

# Keep one row of identifying information per time series
dta_diff_comp <- dta_diff %>%
  distinct(Time_series, Year, Subtribe, Habit)

# ============================================================
# Final Dataset for Plotting
# ============================================================

# Join cumulative counts with metadata and enforce consistent Habit ordering
dta_cum <- new_dta_diff %>%
  left_join(dta_diff_comp, by = "Time_series") %>%
  mutate(Habit = factor(Habit, levels = c("A", "P")))


```

## Figure 1 - Branch initiation rates in annual and perennial core Pooideae species pairs. 


```{r}

# ============================================================
# Plot Settings: Colors and Facet Labels
# ============================================================

# Consistent color mapping for life-history categories
cols <- c(
  "A" = "#f0be6f",  # Annual (yellow)
  "P" = "#1b4543"   # Perennial (dark green)
)

# Parsed expressions for italicized facet labels
label_expr <- as_labeller(
  c(
    "Brachypodium (2021)"       = "italic('Brachypodium (2021)')",
    "Brachypodium (2022)"       = "italic('Brachypodium (2022)')",
    "Bromus"                    = "italic('Bromus')",
    "Hordeum"                   = "italic('Hordeum')",
    "Briza"                     = "italic('Briza')",
    "Lamarckia & Dactylis"      = "italic('Lamarckia & Dactylis')",
    "Festuca"                   = "italic('Festuca')",
    "Phalaris"                  = "italic('Phalaris')",
    "Beckmannia & Arctagrostis" = "italic('Beckmannia & Arctagrostis')"
  ),
  label_parsed
)

# ============================================================
# Figure 1: Cumulative Tillers Over Time (Faceted by Taxon)
# ============================================================

fig1 <- ggplot(
  dta_cum,
  aes(x = Ordered_Days_shoot, y = cumulative_sum, color = Habit)
) +
  geom_point(
    position = position_jitter(width = 0.3, height = 0.3),
    size = 2,
    alpha = 0.7
  ) +
  facet_wrap(
    ~ Subtribe,
    nrow = 5,
    ncol = 2,
    labeller = labeller(Subtribe = label_expr)
  ) +
  scale_color_manual(
    values = cols,
    na.value = "#5f5f5f",
    labels = c("A" = "Annual", "P" = "Perennial"),
    name = "Life history"
  ) +
  labs(
    x = "Time (d)",
    y = "Number of tillers"
  ) +
  theme_bw()

print(fig1)

```


# Table S1 - Pairwise comparisons of estimated marginal means for the different species-pairs with respect to branching rate.

Fitting a multiple mixed model, with the number of days between each shoot after the first sprout as the response variable and Habitat and Subtribe, as well as the interaction between these, as fixed effects.
Individual measurement is set as a random effect nested within the interaction between Habitat and Subtribe:

$$
 Y_{ijkt} = \mu + \tau_i + \gamma_j + (\tau \times \gamma)_{ij} + u_{k(ij)} + e_{ijkt}
$$

where:

$$
\begin{aligned}
Y_{ijkt} &:\ \text{Days after first shoot for individual } k \text{ in group } (i,j) \text{ at time } t \\
\tau_i   &:\ \text{Life history (Habit) } i \\
\gamma_j &:\ \text{Subtribe } j \\
u_{k(ij)}&:\ \text{Random intercept for individual } k \text{ nested within Habit } \times \text{ Subtribe} \\
e_{ijkt} &:\ \text{Residual error for observation } t
\end{aligned}
$$


```{r}

# ============================================================
# Mixed-Effects Model: Sum-to-Zero Contrasts
# ============================================================

# With sum-to-zero contrasts
options(contrasts = c("contr.sum", "contr.sum"))

# ============================================================
# Fit the Mixed-Effects Model (glmmTMB)
# ============================================================

mod_mixed <- glmmTMB(
  log(Difference + 0.1) ~ Habit * Subtribe + (1 | Habit:Subtribe/Individual_new),
  data = dta_diff
)

#summary(mod_mixed)

# ============================================================
# Model Diagnostics
# ============================================================

# Assumption checks (quick diagnostics)
#fitted_values <- fitted(mod_mixed)
#residuals <- resid(mod_mixed)

#qqnorm(residuals)
#qqline(residuals)

#plot_data <- data.frame(Fitted = fitted_values, Residuals = residuals)

#ggplot(plot_data, aes(x = Fitted, y = Residuals)) +
#  geom_point() +
#  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
#  labs(x = "Fitted values", y = "Residuals", title = "Residuals vs #Fitted") +
#  theme_minimal()

# ============================================================
# Fixed Effects Table (95% Confidence Intervals)
# ============================================================

fixef_tab <- tidy(mod_mixed,
                  effects   = "fixed",
                  conf.int  = TRUE,
                  conf.level = 0.95)

fixef_tab <- fixef_tab %>% 
  rename(
    Term      = term,
    Estimate  = estimate,
    SE        = std.error,
    z_value   = statistic,  
    CI_lower  = conf.low,
    CI_upper  = conf.high
  )

# ============================================================
# Random Effects Table
# ============================================================

vc <- glmmTMB::VarCorr(mod_mixed)
vmat <- as.data.frame(vc$cond)

randef_tab <- tibble(
  Group = c("Subtribe:Habit", "Individual_new:Subtribe:Habit"),
  Term = "(Intercept)",
  Variance = as.numeric(vmat[1, ]),
  SD = sqrt(Variance)
)

# ============================================================
# Estimated Marginal Means and Pairwise Contrasts (Back-transformed)
# ============================================================

# Get estimated marginal means for each Habit | Subtribe combination
emm_log <- emmeans(mod_mixed, ~ Habit | Subtribe)
emm_orig <- regrid(emm_log, transform = "response", inv.link = exp)
emm_df <- as.data.frame(emm_orig)

# Pairwise contrasts within each Subtribe (Tukey-adjusted)
contrasts_tab <- as.data.frame(pairs(emm_orig, adjust = "tukey"))

# ============================================================
# Optional: Print Output Tables
# ============================================================

print(fixef_tab)
print(randef_tab)
print(contrasts_tab)

```

# (2) annuals will flower earlier and exhibit more synchronized within-individual branch flowering

This data-wrangling step prepares the flowering dataset by constructing an ordered within-individual time index. Observations are grouped by taxon, life-history category, and individual, segmented into time series (reset when Days shoot == 1), and then sorted to generate a sequential day counter (Ordered_Days). A flowering-focused subset (dta_flow) is extracted for selected taxa, and Subtribe is refactored to enforce a consistent plotting and reporting order in both the full (dta_ord) and subset datasets.

```{r}
# ============================================================
# Time-Series Indexing for Flowering Analyses
# ============================================================

# Create an ordered within-individual time index (per taxon × life history)
dta_ord <- dta %>%
  filter(Subtribe != "Brachypodium (2021)") %>%
  group_by(Subtribe, Habit, Individual_new) %>%
  mutate(Time_series = cumsum(`Days shoot` == 1)) %>%
  arrange(Subtribe, Habit, Individual_new, Time_series, `Days shoot`) %>%
  mutate(Ordered_Days = row_number()) %>%
  ungroup()

# ============================================================
# Subset for Flowering
# ============================================================

dta_flow <- dta_ord %>%
  filter(Subtribe %in% c("Brachypodium (2022)", "Festuca", "Hordeum"))

# ============================================================
# Factor Level Ordering
# ============================================================

dta_ord <- dta_ord %>%
  mutate(
    Subtribe = factor(Subtribe, levels = c(
      "Brachypodium (2022)",
      "Bromus",
      "Hordeum",
      "Briza",
      "Lamarckia & Dactylis",
      "Festuca",
      "Phalaris",
      "Beckmannia & Arctagrostis"
    ))
  )

dta_flow <- dta_flow %>%
  mutate(
    Subtribe = factor(Subtribe, levels = c(
      "Brachypodium (2022)",
      "Hordeum",
      "Festuca"
    ))
  )

# ============================================================
# Sample Size Summaries
# ============================================================

cat(
  "\nSample size summary (dta_ord):\n",
  "Rows (observations): ", nrow(dta_ord), "\n",
  "Individuals:         ", dplyr::n_distinct(dta_ord$Individual_new), "\n",
  "Time series:         ", dplyr::n_distinct(dta_ord$Time_series), "\n",
  "Subtribes:           ", dplyr::n_distinct(dta_ord$Subtribe), "\n\n",
  sep = ""
)

cat(
  "Sample size summary (dta_flow):\n",
  "Rows (observations): ", nrow(dta_flow), "\n",
  "Individuals:         ", dplyr::n_distinct(dta_flow$Individual_new), "\n",
  "Time series:         ", dplyr::n_distinct(dta_flow$Time_series), "\n",
  "Subtribes:           ", dplyr::n_distinct(dta_flow$Subtribe), "\n\n",
  sep = ""
)

```

## Figure 2 - Heading dates of reproductive branches in annual and perennial species pairs of core Pooideae

Figure 2 illustrates flowering timing across taxa (Subtribe) and life-history (habit) using data from dta_ord. Points represent individual observations, with time in days on the x-axis (Days flowering1) and ordered flowering day on the y-axis (Ordered_Days); jitter is applied to reduce overplotting. Panels are faceted by taxon, with italicized facet labels, and colors distinguish annual (A) and perennial (P) species.

```{r}
# ============================================================
# Facet Labels (Parsed, Italicized Taxon Names)
# ============================================================

label_expr <- as_labeller(
  c(
    "Brachypodium (2022)"       = "italic('Brachypodium (2022)')",
    "Bromus"                    = "italic('Bromus')",
    "Hordeum"                   = "italic('Hordeum')",
    "Briza"                     = "italic('Briza')",
    "Lamarckia & Dactylis"      = "italic('Lamarckia & Dactylis')",
    "Festuca"                   = "italic('Festuca')",
    "Phalaris"                  = "italic('Phalaris')",
    "Beckmannia & Arctagrostis" = "italic('Beckmannia & Arctagrostis')"
  ),
  label_parsed
)

# ============================================================
# Figure 2: Flowering Timing (Faceted by Taxon)
# ============================================================

fig2 <- ggplot(
  dta_ord,
  aes(x = `Days flowering1`, y = Ordered_Days, color = Habit, group = interaction(Subtribe, Habit))
) +
  geom_point(
    position = position_jitter(width = 0.3, height = 0.3),
    size = 2,
    alpha = 0.7
  ) +
  facet_wrap(
    ~ Subtribe,
    ncol = 2,
    labeller = labeller(Subtribe = label_expr)
  ) +
  scale_color_manual(
    values = c("A" = "#f0be6f", "P" = "#1b4543"),
    na.value = "#5f5f5f",
    labels = c("A" = "Annual", "P" = "Perennial"),
    name = "Life history"
  ) +
  labs(
    x = "Time (d)",
    y = "Flowering day"
  ) +
  theme_bw()

print(fig2)

```

# Table S1 - Pairwise comparisons of estimated marginal means with respect to flowering time. The table only includes comparisons for the species-pairs where both the annual and the perennial flowered. 


Fitting a multiple mixed model, heading dates for all reproductive branches in our pairs of annual-perennial taxa as response and Habitat and Subtribe, as well as the interaction between these, as fixed effects.
Individual measurement is set as a random effect nested within the interaction between Habitat and Subtribe:

$$
 Y_{ijkt} = \mu + \tau_i + \gamma_j + (\tau \times \gamma)_{ij} + u_{k(ij)} + e_{ijkt}
$$

where:

$$
\begin{align*}
Y_{ijkt} & : \text{Days flowering after first shot } i \text{ in group } j \\
\tau_i & : \text{Habitat } i \\
\gamma_j & : \text{Subtribe } j \\
u_{k(ij)} & : \text{Individual } k \text{ nested within the interaction between Habitat and Subtribe} \\
e_{ijkt} & : \text{Residual error term for observation } t
\end{align*}
$$



```{r}

# ============================================================
# Mixed-Effects Model (Flowering Time): Sum-to-Zero Contrasts
# ============================================================

# With sum-to-zero contrasts (for Type-III style interpretation)
options(contrasts = c("contr.sum", "contr.sum"))

# ============================================================
# Fit the Mixed-Effects Model (glmmTMB)
# ============================================================

mod_mixed_flow <- glmmTMB(
  `Days flowering1` ~ Habit * Subtribe + (1 | Habit:Subtribe/Individual_new),
  data = dta_flow
)
#summary(mod_mixed_flow)

# ============================================================
# Model Diagnostics
# ============================================================

#fitted_values <- fitted(mod_mixed_flow)
#residuals <- resid(mod_mixed_flow)

# QQ plot
#qqnorm(residuals)
#qqline(residuals)

# Residuals vs Fitted
#plot_data <- data.frame(Fitted = fitted_values, Residuals = residuals)

#ggplot(plot_data, aes(x = Fitted, y = Residuals)) +
#  geom_point() +
#  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
#  labs(x = "Fitted values", y = "Residuals", title = "Residuals vs Fitted") +
#  theme_minimal()

# ============================================================
# Fixed Effects Table (95% Confidence Intervals)
# ============================================================

fixef_tab_flow <- tidy(
  mod_mixed_flow,
  effects    = "fixed",
  conf.int   = TRUE,
  conf.level = 0.95
) %>%
  rename(
    Term      = term,
    Estimate  = estimate,
    SE        = std.error,
    z_value   = statistic,
    p_value   = p.value,
    CI_lower  = conf.low,
    CI_upper  = conf.high
  )

# ============================================================
# Random Effects Table (Variance and SD)
# ============================================================

vc_flow <- glmmTMB::VarCorr(mod_mixed_flow)
vmat_flow <- as.data.frame(vc_flow$cond)

randef_tab_flow <- tibble(
  Group = c("Subtribe:Habit", "Individual_new:Subtribe:Habit"),
  Term = "(Intercept)",
  Variance = as.numeric(vmat_flow[1, ]),
  SD = sqrt(Variance)
)

# ============================================================
# Estimated Marginal Means and Pairwise Contrasts
# ============================================================

# Estimated marginal means for Habit within each Subtribe
emm_flow <- emmeans(mod_mixed_flow, ~ Habit | Subtribe)
emm_flow_df <- as.data.frame(emm_flow)

# Pairwise contrasts within each Subtribe (Tukey-adjusted)
contrasts_flow_tab <- as.data.frame(pairs(emm_flow, adjust = "tukey"))


# ============================================================
# Optional: Print Output Tables
# ============================================================

 print(fixef_tab_flow)
 print(randef_tab_flow)
 print(contrasts_flow_tab)

```


To assess whether flowering was more synchronous between habitats, we quantified the within-individual flowering interval as the difference between the latest and earliest recorded flowering day. This yielded one flowering interval per individual. Individuals without recorded flowering observations were excluded from this analysis. After filtering, 50 individuals remained, distributed among the subtribes Brachypodium (n = 21), Hordeum (n = 20), and Festuca (n = 9). Flowering interval was analysed using a linear mixed-effects model with habitat, subtribe, and their interaction as fixed effects.

```{r}
# ============================================================
# Mixed-Effects Model (Flowering Interval): Sum-to-Zero Contrasts
# ============================================================


# ============================================================
# Prepare Data: Flowering interval per individual
# ============================================================

dta_interval <- dta_flow %>%
  filter(!is.na(`Days flowering1`)) %>%
  group_by(Subtribe, Habit, Individual_new) %>%
  summarise(
    flowering_range = max(`Days flowering1`) - min(`Days flowering1`),
    .groups = "drop"
  )

# ============================================================
# Linear Model (Flowering Interval)
# ============================================================

options(contrasts = c("contr.sum", "contr.sum"))

mod_interval <- lm(
  flowering_range ~ Habit * Subtribe,
  data = dta_interval
)

#summary(mod_interval)

# ============================================================
# Model Diagnostics
# ============================================================

#plot(mod_interval)

# ============================================================
# Fixed Effects Table (95% Confidence Intervals)
# ============================================================

fixef_tab_interval <- broom::tidy(
  mod_interval,
  conf.int = TRUE,
  conf.level = 0.95
) %>%
  dplyr::rename(
    Term     = term,
    Estimate = estimate,
    SE       = std.error,
    t_value  = statistic,
    p_value  = p.value,
    CI_lower = conf.low,
    CI_upper = conf.high
  )

# ============================================================
# Estimated Marginal Means and Pairwise Contrasts
# ============================================================

emm_interval <- emmeans(mod_interval, ~ Habit | Subtribe)
emm_interval_df <- as.data.frame(emm_interval)

contrasts_interval_tab <- as.data.frame(
  pairs(emm_interval, adjust = "tukey")
)

# ============================================================
# Optional: Print Output Tables
# ============================================================

print(fixef_tab_interval)
print(contrasts_interval_tab)

```


# (3) flowering probability will be determined primarily by branch age


```{r}

# ============================================================
# Data Import and Variable Renaming (Figure 5)
# ============================================================

dta <- read_excel("Data/Data 1.xlsx", sheet = "Fig. 5b") %>%
  rename(
    flowering_percent  = `Flowering %`,
    average_age_branch = `Average age branch`
  )

# ============================================================
# Taxon-Specific Subsets
# ============================================================

dta_festuca <- dta %>%
  filter(Subtribe == "Festuca")

dta_hordeum <- dta %>%
  filter(Subtribe == "Hordeum")

dta_brachypodium <- dta %>%
  filter(Subtribe == "Brachypodium")

```

## Figur 5

Figure 5 shows model-predicted effects of average branch age on flowering percentage for Festuca, Hordeum, and Brachypodium. Separate linear models were fitted for each genus, including an interaction between branch age and life-history strategy (annual vs. perennial). Lines represent fitted relationships, while shaded ribbons indicate confidence intervals. The figure highlights genus-specific differences in both the magnitude and shape of the age–flowering relationship, as well as contrasting responses between annual and perennial taxa.

```{r}

# ============================================================
# Linear Models and Effect Plots
# ============================================================

# Fit the same linear model separately for each genus
data_list <- list(
  Festuca      = dta_festuca,
  Hordeum      = dta_hordeum,
  Brachypodium = dta_brachypodium
)

options(contrasts = c("contr.treatment", "contr.poly"))

model_list <- lapply(
  data_list,
  function(d) lm(flowering_percent ~ average_age_branch * Habit, data = d)
)

# ============================================================
# Model Diagnostics: QQ Plots
# ============================================================

#op <- par(mfrow = c(1, length(model_list)), mar = c(4, 4, 2, 1))

#for (nm in names(model_list)) {
#  m <- model_list[[nm]]
#  qqnorm(resid(m), main = paste("QQ plot:", nm))
##  qqline(resid(m))
#}

#par(op)

# Inspect model summaries
# lapply(model_list, summary)

# ============================================================
# Predicted Effects 
# ============================================================

eff_list <- lapply(
  model_list,
  function(m) effect("average_age_branch*Habit", m)
)

eff_df <- bind_rows(
  lapply(names(eff_list), function(genus) {
    as.data.frame(eff_list[[genus]]) %>%
      mutate(Genus = genus)
  })
)

# ============================================================
# Facet Labels 
# ============================================================

label_expr_genus <- as_labeller(
  c(
    "Festuca"      = "italic('Festuca')",
    "Hordeum"      = "italic('Hordeum')",
    "Brachypodium" = "italic('Brachypodium')"
  ),
  label_parsed
)

# ============================================================
# Effect plot
# ============================================================

fig5 <- ggplot(
  eff_df,
  aes(
    x = average_age_branch,
    y = fit,
    group = Habit,
    color = Habit,
    fill  = Habit
  )
) +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.15, color = NA) +
  geom_line(linewidth = 1) +
  facet_wrap(
    ~ Genus,
    nrow = 1,
    scales = "free_x",
    labeller = labeller(Genus = label_expr_genus)
  ) +
  scale_color_manual(
    values = c("A" = "#f0be6f", "P" = "#1b4543"),
    na.value = "#5f5f5f",
    labels = c("A" = "Annual", "P" = "Perennial"),
    name   = "Life history"
  ) +
  scale_fill_manual(
    values = c("A" = "#f0be6f", "P" = "#1b4543"),
    na.value = "#5f5f5f",
    labels = c("A" = "Annual", "P" = "Perennial"),
    name   = "Life history"
  ) +
  labs(
    x = "Average age branch",
    y = "Flowering percent (predicted)"
  ) +
  theme_bw()

print(fig5)

# ============================================================
# Model Summary Table
# ============================================================


modelsummary(
  model_list,
  statistic = "({std.error})",
  stars = TRUE,
  output = "markdown"
)


```

# (5) perennial core species branch faster than non-core perennials

## Dataimport

This code imports the Figure 6 dataset and prepares it for branching-rate analyses. It converts key identifiers (Subtribe, Individual) to factors, assigns a standardized individual ID (Individual_new) using dense_rank(), and defines time series segments by incrementing Time_series whenever Days shoot == 1. Observations are restricted to Days shoot ≤ 38, then ordered within each time series to compute the interval between successive shoot events (Difference = diff(Days shoot)). The first observation in each series (with undefined difference) is removed, and the core/non-core classification is stored as CoreStatus.

```{r}

# ============================================================
# Data Import and Pre-processing (Figure 6)
# ============================================================

dta_diff <- read_excel("Data/Data 1.xlsx", sheet = "Fig. 6") %>%
  mutate(
    Subtribe     = factor(Subtribe),
    Individual   = factor(Individual),
    Individual_new = factor(paste0("ID", dense_rank(Individual))),
    Time_series  = cumsum(`Days shoot` == 1)
  ) %>%
  filter(`Days shoot` <= 38) %>%
  group_by(Time_series) %>%
  arrange(Time_series, `Days shoot`) %>%
  mutate(
    Ordered_Days_shoot = `Days shoot`,
    Difference = c(NA, diff(Ordered_Days_shoot))
  ) %>%
  filter(!is.na(Difference)) %>%
  ungroup() %>%
  mutate(CoreStatus = `Core/Non-core`)

cat(
  "\nSample size used in analysis:\n",
  "Rows (observations): ", nrow(dta_diff), "\n",
  "Individuals:         ", dplyr::n_distinct(dta_diff$Individual_new), "\n",
  "Time series:         ", dplyr::n_distinct(dta_diff$Time_series), "\n",
  "CoreStatus:           ", dplyr::n_distinct(dta_diff$Subtribe), "\n\n",
  sep = ""
)


```
## Figure S2 Branching rates in perennial core versus non-core Pooideae. 

Mean time between successive shoots per individual. We calculated the mean interval (days) between successive shoot initiation events for each individual and compared core vs. non-core taxa.

```{r}

# ============================================================
# Figure S2: Mean Time Between Successive Shoots (Core vs Non-core)
# ============================================================

# Average interval between shoots per individual
branch_speed <- dta_diff %>%
  group_by(Individual_new, CoreStatus) %>%
  summarise(
    mean_branch_interval = mean(Difference, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    CoreStatus = factor(CoreStatus, levels = c("core", "non-core"))
  )

figS2 <- ggplot(branch_speed, aes(x = CoreStatus, y = mean_branch_interval, fill = CoreStatus)) +
  geom_boxplot() +
  scale_fill_manual(
    values = c("core" = "#1b4543", "non-core" = "#b3d0c6"),
    labels = c("Core", "Non-core"),
    name = NULL
  ) +
  labs(
    x = NULL,
    y = "Mean time between successive shoots (days)"
  ) +
  theme_bw()

print(figS2)

```

## Figure 6 - Branch emergence trajectories in perennial core versus non-core species

This plot shows the cumulative number of shoots per individual over time, illustrating differences in shoot emergence dynamics between groups.

```{r}

# ============================================================
# Figure 6: Cumulative Shoot Number Over Time (Core vs Non-core)
# ============================================================

fig6 <- dta_diff %>%
  group_by(Individual_new, CoreStatus) %>%
  arrange(Ordered_Days_shoot, .by_group = TRUE) %>%
  mutate(Shoot_number = row_number()) %>%
  ungroup() %>%
  ggplot(aes(
    x = Ordered_Days_shoot,
    y = Shoot_number,
    color = CoreStatus,
    group = Individual_new
  )) +
  geom_line(alpha = 0.4) +
  stat_summary(
    aes(group = CoreStatus, color = CoreStatus),
    fun = mean,
    geom = "line",
    linewidth = 1.5
  ) +
  scale_color_manual(
    values = c("core" = "#1b4543", "non-core" = "#b3d0c6"),
    labels = c("Core", "Non-core"),
    name = NULL
  ) +
  labs(
    x = "Time (d)",
    y = "Cumulative number of shoots"
  ) +
  theme_bw()

print(fig6)

```
## analysis 

```{r}
# ============================================================
# Mixed-Effects Model (Figure 6): Core vs Non-core
# ============================================================

# With sum-to-zero contrasts
#options(contrasts = c("contr.sum", "contr.sum"))

# Fit the mixed-effects model
mod_mixed <- glmmTMB(
  Difference ~ CoreStatus + (1 | Subtribe/Individual),
  data = dta_diff
)

#summary(mod_mixed)

# ============================================================
# Model Diagnostics
# ============================================================

#fitted_values <- fitted(mod_mixed)
#residuals <- resid(mod_mixed)

# QQ plot (optional)
# qqnorm(residuals)
## qqline(residuals)

#plot_data <- data.frame(Fitted = fitted_values, Residuals = residuals)

#p_error <- ggplot(plot_data, aes(x = Fitted, y = Residuals)) +
#  geom_point() +
#  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
#  labs(x = "Fitted values", y = "Residuals", title = "Residuals vs Fitted") +
#  theme_minimal()

#print(p_error)

# ============================================================
# Fixed Effects Table (95% Confidence Intervals)
# ============================================================

fixef_tab <- tidy(
  mod_mixed,
  effects    = "fixed",
  conf.int   = TRUE,
  conf.level = 0.95
) %>%
  rename(
    Term      = term,
    Estimate  = estimate,
    SE        = std.error,
    z_value   = statistic,
    p_value   = p.value,
    CI_lower  = conf.low,
    CI_upper  = conf.high
  )

# ============================================================
# Random Effects Table (Variance and SD)
# ============================================================

vc <- glmmTMB::VarCorr(mod_mixed)

randef_tab <- lapply(names(vc$cond), function(g) {
  m <- vc$cond[[g]]
  tibble(
    Group    = g,
    Term     = rownames(m),
    Variance = diag(m),
    SD       = sqrt(diag(m))
  )
}) %>%
  bind_rows()


# ============================================================
# Model Results: Effect of CoreStatus
# ============================================================

eff_plot <- effect("CoreStatus", mod_mixed)
eff_df <- as.data.frame(eff_plot)

# ============================================================
# Print Output Tables
# ============================================================

 print(fixef_tab)
 print(randef_tab)
 print(eff_df)

```

